# 算法设计与分析

## <font color="blue">分治</font>

## <font color="red">动态规划</font>

# 算法设计笔记

## 动态规划

### OBST

递推关系e[i,j] = pr + e[i, r-1] + w(i, r- 1) + e[r + 1, j] + w(r + 1,j)    //w节点概率之和，因为变成了子树，所有节点要增加一次搜索

= e[i, r - 1] + e[r + 1, j] +w(i ,j)

//    很类似矩阵连乘

## <font color="green">贪心</font>

### 1.磁带存储与读取

### 2.活动安排

n个活动，编号分别为1,…,n，时长分别为L[1],…,L[n]，最后期限为D[1],…,D[n]，在安排方案π中，记延迟λ(k)=max{0,∑L[π(i)] - D[π(i)]} //延迟即为在最后期限之后多久完成的

//先L1 10再L2 100,D1 = 20 D2 = 50 则λ1 = 0 λ2 = 110 - 50 = 60

问题：求最优排列π⋆使最大延迟maxλπ(k)最小    //所有延迟中的最大值 的最小值所对应的方案

【按最后期限升序】

what if求延迟之和？

【按Li + Di的升序排序】

L      10  20  50  100 250

D     50  60  40  20   150

sum 60  80  90  120 400

w 0.2 0.333 1.25 5 1.6 

性价比升序

0 0 40 180 410

sum升序

0 0 40 160 280



L 10 20 50 100 250 200

D 50 60 40 20 150 200

sum 60 80 90 120 400 400

w 0.2 0.333 1.25 5 1.6 1

性价比升序

0

sum升序

## <font color="orange">单源最短路径 SSSP</font>

*求源点到其他所有点的最短路径*

### 1.Ford算法

di表示s到i的已知最短路径，pi为s到i的前驱节点

松弛：if dv > du + w(u,v) then dv = du + w(u,v) pv = u

(1)无向无权图

**BFS** :将源点入队，队列非空时，将队首出队，遍历所有出边，若v可松弛就更新dp和front,并且将v入队

**Θ(|V|+|E|)**

(2)有向无权图

**DFS**: 通过后序DFS得到节点的拓补序，根据拓补序依次松弛入边

a.拓补序可以通过入度进行BFS得到，也可以：

从根节点开始，对他的所有子节点，如果访问过就记录在label中，如果没有就继续访问他的子节点，如此往复就会得到后序遍历。将后序遍历反过来就是拓补排序

b.**拓扑序保证无后效性**：当处理节点v时，所有可能到达v的节点u都已经在label中先于v被处理过

**Θ(|V|+|E|)**

### 2.Bellman-Ford动态规划填表

d<sub>v</sub><sup>k</sup>代表从s到v不超过k条边的最短路径长度，当k=|V|-1时停止即可

d<sub>v</sub><sup>k</sup> = min{d<sub>v</sub><sup>k-1</sup>, min<sub>u&ne;v</sub> {d<sub>u</sub><sup>k-1</sup>+w(u,v) } }

a.关键代码实现

```python
for _ in range(len(g) - 1):  # 遍历|V|-1次
        for u in g:
            for v in g[u]:  # 内部的二重for循环遍历所有边
                if d[v] > d[u] + g[u][v]:           # 松弛
                    d[v], p[v] = d[u] + g[u][v], u  # 更新当前最短距离和前驱
```

b.负环检测

若没有负环，则满足三角不等式，对所有边检测一遍，assert(dv <= du + w(u,v))

c.遍历次数

不一定是|V|-1次，相邻两轮d表不变即可

d.备份上一轮的d[]表？

备份则代表是动态规划，但是如果不备份就可以减少迭代次数，最好情况1轮即完成，最坏情况与备份状态相同

**Θ(|V||E|)**

### 3.Dijkstra算法【贪心算法】

a.只允许1次出入队**没有负权**

对于每一轮dp,由于没有负权导致当前最小的节点之后一定不会被更新为更小的，所以可以利用优先队列，每次将最小的距离节点固定住（出队）不再更改，即一旦从优先队列中弹出节点u，则d[u]已经是最终最短距离

b.允许多次出入队**可以处理负权边，不可以处理负权环**

迪杰斯特拉原本的算法其实也可以处理含负权重的边，但是有可能达到指数复杂度，原本的算法允许多次出队和入队（而且处理没有负边的效率与不允许多次初入队的效率相同）

```python
while not q.empty():
    _, u = q.get() # 获取队首元素点u 
    in_q[u] = False # 更新点u的在队状态 
    for v in g[u]: # 更新u指向的点的最短路径 
        if d[v] > d[u] + g[u][v]: # 边(u,v)可以松弛 
        if in_q[v]: # 如果点v已在队 让其出队
# 这里出队是为了更改d[v]的值，然后再入队，因为优先队列无法更改其中的元素的之后自动排序，所以采用删除之后再添加的方法
# 用heapdict包自带decrease key 
            q.queue.remove([d[v], v]) 

        d[v], p[v] = d[u] + g[u][v], u # 更新最短距离和前驱
        q.put([d[v], v]) # 点v入队 
        in_q[v] = True
```

查分约束系统：

Ax<=b的不定方程组，转换为有向带权图，引入一个v0到其他点的权重为0

若存在负环，无解

若无负环，每个x取到v0的最短距离即为一个解

## <font color="orange">全结点对最短路径</font>

*求任意两点点的最短路径*

##### Floyd-Warshall

##### Johnson

引入源点0，从源点开始运行Bellman-Ford并且更新权重为w(u,v) + h(u) - h(v)

## <font color="pink">回溯法</font>

n皇后

哈密顿

子集合数

分配问题

(将所选行列删去，然后找上下界)





# 实验课记录

## 共 8 / 18（22）

### 分治

2（P2678 黄 P1242蓝）

## 动态规划

6（P4017黄 P1434黄 P4999绿 P1220绿 P1854黄 P1352黄）

### 贪心

4（P1106黄 P1080绿 P1658黄 P1090黄）
git init
git sparse-checkout init -cone
git sparse-checkout set test
git remote add origin 网址
git pull orogin master
就把对面的子文件夹test搞过来了



<font color="orange">Period 1</font>

1.| 1   | **P2678** | 跳石头 | 分治  | 二分  |
2.| 2   | **P1242** | 新汉诺塔 | 分治  |     |

<font color="orange">Period 2</font>

3.| 4   | **P1220** | 关路灯 | 动态规划 | 搜索  |
4.| 6   | **P1854** | 花店橱窗布置 | 动态规划 |     |
5.| 7   | **P4999** | 烦人的数学作业 | 动态规划 | 数位、记忆化搜索 |
6.| 9   | **P1434** | 滑雪  | 动态规划 | 记忆化搜索 |
7.| 10  | **P4017** | 最大食物链计数 | 动态规划 | 拓扑排序 |
8.| 11  | **P1352** | 消息传递 | 动态规划 | 树形 ，王一然推荐 |

<font color="orange">Period 3</font>

9.| 12  | **P1106** | 删数问题 | 贪心  |     |
10.| 13  | **P1080** | 国王游戏 | 贪心  |     |
| 14  | **P2512** | 糖果传递 | 贪心  | 中位数 |
| 15  | **P2127** | 序列排序 | 贪心  |     |
| 16  | **P1658** | 购物  | 贪心  |     |
12.| 17  | **P1090** | 合并果子 | 贪心  | 优先队列 

<font color="orange">Period 4 & 5</font>

| 18  | **P1443** | 马的遍历 | 搜索  | BFS |
| 19  | **P1135** | 奇怪的电梯 | 搜索  | BFS |
| 20  | **P2895** | Meteor Shower S | 搜索  | BFS |
| 21  | **P1825** | Corn Maze S | 搜索  | BFS |
| 22  | **P1433** | 吃奶酪 | 搜索  | DFS、状态压缩DP |
| 23  | **P1784** | 数独  | 搜索  | DFS |
| 24  | **P1141** | 01迷宫 | 搜索  | DFS、记忆化搜索 |
| 25  | **P1019** | 单词接龙 | 搜索  | DFS |
| 26  | **P2349** | 金字塔 | 搜索  | A*  |
| 27  | **P2324** | 骑士精神 | 搜索  | IDA* |
| 28  | **P5691** | 方程的解数 | 搜索  | 折半搜索 |
| 29  | **P3067** | Balanced Cow Subsets G | 搜索  | 折半搜索 |

<font color="orange">Period 6</font>

| 30  | **P3809** | 后缀排序 | 后缀数组 |     |
| 31  | **P2852** | Milk Patterns G | 后缀数组 |     |
| 32  | **P2870** | Best Cow Line G | 后缀数组 |     |
| 33  | **P3374** | 树状数组 1 | 树状数组 |     |
| 34  | **P3368** | 树状数组 2 | 树状数组 | 区间查询 |
| 35  | **P3605** | Promotion Counting P | 树状数组 |     |
| 36  | **P1816** | 忠诚  | 线段树 | RMQ、ST表 |
| 37  | **P3373** | 线段树 2 | 线段树 |     |
| 38  | **P1904** | 天际线 | 线段树 | 扫描线 |
| 39  | **P1993** | 小K的农场 | 差分约束系统 |     |
| 40  | **P3275** | 糖果  | 差分约束系统 |     |
| 41  | **P1250** | 种树  | 差分约束系统 |     |
| 42  | **P1111** | 修复公路 | 并查集 |     |
| 43  | **P1196** | 银河英雄传说 | 并查集 |     |
| 44  | **P2024** | 食物链 | 并查集 |     |
| 45  | **P1197** | 星球大战 | 并查集 |     |
| 46  | **P2756** | 飞行员配对方案问题 | 网络流 |     |
| 47  | **P1314** | 聪明的质监员 | 前缀和 |     |
| 48  | **P1726** | 上白泽慧音 | Tarjan |     |
| 49  | **P3379** | 最近公共祖先（LCA） | LCA/RMQ | 倍增法、欧拉序+ST表、Tarjan |
| 50  | **P3865** | ST 表 && RMQ 问题 | RMQ | ST 表 |


